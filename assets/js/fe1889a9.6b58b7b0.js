"use strict";(self.webpackChunkdocu=self.webpackChunkdocu||[]).push([[3127],{3905:function(t,e,a){a.d(e,{Zo:function(){return m},kt:function(){return u}});var n=a(67294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function i(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function l(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?i(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function o(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},i=Object.keys(t);for(n=0;n<i.length;n++)a=i[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(n=0;n<i.length;n++)a=i[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var d=n.createContext({}),s=function(t){var e=n.useContext(d),a=e;return t&&(a="function"==typeof t?t(e):l(l({},e),t)),a},m=function(t){var e=s(t.components);return n.createElement(d.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},h=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,i=t.originalType,d=t.parentName,m=o(t,["components","mdxType","originalType","parentName"]),h=s(a),u=r,c=h["".concat(d,".").concat(u)]||h[u]||p[u]||i;return a?n.createElement(c,l(l({ref:e},m),{},{components:a})):n.createElement(c,l({ref:e},m))}));function u(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var i=a.length,l=new Array(i);l[0]=h;var o={};for(var d in e)hasOwnProperty.call(e,d)&&(o[d]=e[d]);o.originalType=t,o.mdxType="string"==typeof t?t:r,l[1]=o;for(var s=2;s<i;s++)l[s]=a[s];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},14337:function(t,e,a){a.r(e),a.d(e,{assets:function(){return m},contentTitle:function(){return d},default:function(){return u},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return p}});var n=a(87462),r=a(63366),i=(a(67294),a(3905)),l=["components"],o={},d="Basic Normalization",s={unversionedId:"understanding-airbyte/basic-normalization",id:"understanding-airbyte/basic-normalization",title:"Basic Normalization",description:"High-Level Overview",source:"@site/../docs/understanding-airbyte/basic-normalization.md",sourceDirName:"understanding-airbyte",slug:"/understanding-airbyte/basic-normalization",permalink:"/understanding-airbyte/basic-normalization",draft:!1,editUrl:"https://github.com/airbytehq/airbyte/blob/master/docs/../docs/understanding-airbyte/basic-normalization.md",tags:[],version:"current",frontMatter:{},sidebar:"mySidebar",previous:{title:"Airbyte Specification",permalink:"/understanding-airbyte/airbyte-specification"},next:{title:"Connections and Sync Modes",permalink:"/understanding-airbyte/connections/"}},m={},p=[{value:"High-Level Overview",id:"high-level-overview",level:2},{value:"Example",id:"example",level:2},{value:"Normalization metadata columns",id:"normalization-metadata-columns",level:2},{value:"Why does Airbyte have Basic Normalization?",id:"why-does-airbyte-have-basic-normalization",level:2},{value:"Destinations that Support Basic Normalization",id:"destinations-that-support-basic-normalization",level:2},{value:"Rules",id:"rules",level:2},{value:"Typing",id:"typing",level:3},{value:"Nesting",id:"nesting",level:3},{value:"Arrays",id:"arrays",level:4},{value:"Objects",id:"objects",level:4},{value:"Naming Collisions for un-nested objects",id:"naming-collisions-for-un-nested-objects",level:3},{value:"Naming limitations &amp; truncation",id:"naming-limitations--truncation",level:3},{value:"UI Configurations",id:"ui-configurations",level:2},{value:"Incremental runs",id:"incremental-runs",level:2},{value:"Partitioning, clustering, sorting, indexing",id:"partitioning-clustering-sorting-indexing",level:2},{value:"Extending Basic Normalization",id:"extending-basic-normalization",level:2},{value:"CHANGELOG",id:"changelog",level:2},{value:"airbyte-integration/bases/base-normalization",id:"airbyte-integrationbasesbase-normalization",level:3}],h={toc:p};function u(t){var e=t.components,o=(0,r.Z)(t,l);return(0,i.kt)("wrapper",(0,n.Z)({},h,o,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"basic-normalization"},"Basic Normalization"),(0,i.kt)("h2",{id:"high-level-overview"},"High-Level Overview"),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"The high-level overview contains all the information you need to use Basic Normalization when pulling from APIs. Information past that can be read for advanced or educational purposes."))),(0,i.kt)("p",null,"When you run your first Airbyte sync without the basic normalization, you'll notice that your data gets written to your destination as one data column with a JSON blob that contains all of your data. This is the ",(0,i.kt)("inlineCode",{parentName:"p"},"_airbyte_raw_")," table that you may have seen before. Why do we create this table? A core tenet of ELT philosophy is that data should be untouched as it moves through the E and L stages so that the raw data is always accessible. If an unmodified version of the data exists in the destination, it can be retransformed without needing to sync data again."),(0,i.kt)("p",null,"If you have Basic Normalization enabled, Airbyte automatically uses this JSON blob to create a schema and tables with your data in mind, converting it to the format of your destination. This runs after your sync and may take a long time if you have a large amount of data synced. If you don't enable Basic Normalization, you'll have to transform the JSON data from that column yourself."),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)("p",null,"Basic Normalization uses a fixed set of rules to map a json object from a source to the types and format that are native to the destination. For example if a source emits data that looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "make": "alfa romeo",\n  "model": "4C coupe",\n  "horsepower": "247"\n}\n')),(0,i.kt)("p",null,"The destination connectors produce the following raw table in the destination database:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE "_airbyte_raw_cars" (\n    -- metadata added by airbyte\n    "_airbyte_ab_id" VARCHAR, -- uuid value assigned by connectors to each row of the data written in the destination.\n    "_airbyte_emitted_at" TIMESTAMP_WITH_TIMEZONE, -- time at which the record was emitted.\n    "_airbyte_data" JSONB -- data stored as a Json Blob.\n);\n')),(0,i.kt)("p",null,"Then, basic normalization would create the following table:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE "cars" (\n    "_airbyte_ab_id" VARCHAR,\n    "_airbyte_emitted_at" TIMESTAMP_WITH_TIMEZONE,\n    "_airbyte_cars_hashid" VARCHAR,\n    "_airbyte_normalized_at" TIMESTAMP_WITH_TIMEZONE,\n\n    -- data from source\n    "make" VARCHAR,\n    "model" VARCHAR,\n    "horsepower" INTEGER\n);\n')),(0,i.kt)("h2",{id:"normalization-metadata-columns"},"Normalization metadata columns"),(0,i.kt)("p",null,"You'll notice that some metadata are added to keep track of important information about each record."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Some are introduced at the destination connector level: These are propagated by the normalization process from the raw table to the final table",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_airbyte_ab_id"),": uuid value assigned by connectors to each row of the data written in the destination."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_airbyte_emitted_at"),": time at which the record was emitted and recorded by destination connector."))),(0,i.kt)("li",{parentName:"ul"},"While other metadata columns are created at the normalization step.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_airbyte_<table_name>_hashid"),": hash value assigned by airbyte normalization derived from a hash function of the record data."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_airbyte_normalized_at"),": time at which the record was last normalized (useful to track when incremental transformations are performed)")))),(0,i.kt)("p",null,"Additional metadata columns can be added on some tables depending on the usage:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"On the Slowly Changing Dimension (SCD) tables:"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_airbyte_start_at"),": equivalent to the cursor column defined on the table, denotes when the row was first seen"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_airbyte_end_at"),": denotes until when the row was seen with these particular values. If this column is not NULL, then the record has been updated and is no longer the most up to date one. If NULL, then the row is the latest version for the record."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_airbyte_active_row"),": denotes if the row for the record is the latest version or not."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_airbyte_unique_key_scd"),": hash of primary keys + cursors used to de-duplicate the scd table."),(0,i.kt)("li",{parentName:"ul"},"On de-duplicated (and SCD) tables:"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"_airbyte_unique_key"),": hash of primary keys used to de-duplicate the final table.")),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"/understanding-airbyte/basic-normalization#Rules"},"normalization rules")," are ",(0,i.kt)("em",{parentName:"p"},"not")," configurable. They are designed to pick a reasonable set of defaults to hit the 80/20 rule of data normalization. We respect that normalization is a detail-oriented problem and that with a fixed set of rules, we cannot normalize your data in such a way that covers all use cases. If this feature does not meet your normalization needs, we always put the full json blob in destination as well, so that you can parse that object however best meets your use case. We will be adding more advanced normalization functionality shortly. Airbyte is focused on the EL of ELT. If you need a really featureful tool for the transformations then, we suggest trying out dbt."),(0,i.kt)("p",null,"Airbyte places the json blob version of your data in a table called ",(0,i.kt)("inlineCode",{parentName:"p"},"_airbyte_raw_<stream name>"),". If basic normalization is turned on, it will place a separate copy of the data in a table called ",(0,i.kt)("inlineCode",{parentName:"p"},"<stream name>"),". Under the hood, Airbyte is using dbt, which means that the data only ingresses into the data store one time. The normalization happens as a query within the datastore. This implementation avoids extra network time and costs."),(0,i.kt)("h2",{id:"why-does-airbyte-have-basic-normalization"},"Why does Airbyte have Basic Normalization?"),(0,i.kt)("p",null,"At its core, Airbyte is geared to handle the EL ","(","Extract Load",")",' steps of an ELT process. These steps can also be referred in Airbyte\'s dialect as "Source" and "Destination".'),(0,i.kt)("p",null,"However, this is actually producing a table in the destination with a JSON blob column... For the typical analytics use case, you probably want this json blob normalized so that each field is its own column."),(0,i.kt)("p",null,"So, after EL, comes the T ","(","transformation",")",' and the first T step that Airbyte actually applies on top of the extracted data is called "Normalization".'),(0,i.kt)("p",null,"Airbyte runs this step before handing the final data over to other tools that will manage further transformation down the line."),(0,i.kt)("p",null,'To summarize, we can represent the ELT process in the diagram below. These are steps that happens between your "Source Database or API" and the final "Replicated Tables" with examples of implementation underneath:'),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(25549).Z,width:"1131",height:"689"})),(0,i.kt)("p",null,"In Airbyte, the current normalization option is implemented using a dbt Transformer composed of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Airbyte base-normalization python package to generate dbt SQL models files"),(0,i.kt)("li",{parentName:"ul"},"dbt to compile and executes the models on top of the data in the destinations that supports it.")),(0,i.kt)("h2",{id:"destinations-that-support-basic-normalization"},"Destinations that Support Basic Normalization"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/integrations/destinations/bigquery"},"BigQuery")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/integrations/destinations/mssql"},"MS Server SQL")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/integrations/destinations/mysql"},"MySQL"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The server must support the ",(0,i.kt)("inlineCode",{parentName:"li"},"WITH")," keyword."),(0,i.kt)("li",{parentName:"ul"},"Require MySQL ",">","= 8.0, or MariaDB ",">","= 10.2.1."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/integrations/destinations/postgres"},"Postgres")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/integrations/destinations/redshift"},"Redshift")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"/integrations/destinations/snowflake"},"Snowflake"))),(0,i.kt)("p",null,'Basic Normalization can be used in each of these destinations by configuring the "basic normalization" field to true when configuring the destination in the UI.'),(0,i.kt)("h2",{id:"rules"},"Rules"),(0,i.kt)("h3",{id:"typing"},"Typing"),(0,i.kt)("p",null,"Airbyte tracks types using JsonSchema's primitive types. Here is how these types will map onto standard SQL types. Note: The names of the types may differ slightly across different destinations."),(0,i.kt)("p",null,"Airbyte uses the types described in the catalog to determine the correct type for each column. It does not try to use the values themselves to infer the type."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"JsonSchema Type"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Resulting Type"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Notes"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"number")),(0,i.kt)("td",{parentName:"tr",align:"left"},"float"),(0,i.kt)("td",{parentName:"tr",align:"left"})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"integer")),(0,i.kt)("td",{parentName:"tr",align:"left"},"integer"),(0,i.kt)("td",{parentName:"tr",align:"left"})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"string")),(0,i.kt)("td",{parentName:"tr",align:"left"},"string"),(0,i.kt)("td",{parentName:"tr",align:"left"})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"bit")),(0,i.kt)("td",{parentName:"tr",align:"left"},"boolean"),(0,i.kt)("td",{parentName:"tr",align:"left"})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"boolean")),(0,i.kt)("td",{parentName:"tr",align:"left"},"boolean"),(0,i.kt)("td",{parentName:"tr",align:"left"})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"string")," with format label ",(0,i.kt)("inlineCode",{parentName:"td"},"date-time")),(0,i.kt)("td",{parentName:"tr",align:"left"},"timestamp with timezone"),(0,i.kt)("td",{parentName:"tr",align:"left"})),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"array")),(0,i.kt)("td",{parentName:"tr",align:"left"},"new table"),(0,i.kt)("td",{parentName:"tr",align:"left"},"see ",(0,i.kt)("a",{parentName:"td",href:"/understanding-airbyte/basic-normalization#Nesting"},"nesting"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"object")),(0,i.kt)("td",{parentName:"tr",align:"left"},"new table"),(0,i.kt)("td",{parentName:"tr",align:"left"},"see ",(0,i.kt)("a",{parentName:"td",href:"/understanding-airbyte/basic-normalization#Nesting"},"nesting"))))),(0,i.kt)("h3",{id:"nesting"},"Nesting"),(0,i.kt)("p",null,"Basic Normalization attempts to expand any nested arrays or objects it receives into separate tables in order to allow more ergonomic querying of your data."),(0,i.kt)("h4",{id:"arrays"},"Arrays"),(0,i.kt)("p",null,"Basic Normalization expands arrays into separate tables. For example if the source provides the following data:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "make": "alfa romeo",\n  "model": "4C coupe",\n  "limited_editions": [\n    { "name": "4C spider", "release_year": 2013 },\n    { "name" : "4C spider italia" , "release_year":  2018 }\n  ]\n}\n')),(0,i.kt)("p",null,"The resulting normalized schema would be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE "cars" (\n    "_airbyte_cars_hashid" VARCHAR,\n    "_airbyte_emitted_at" TIMESTAMP_WITH_TIMEZONE,\n    "_airbyte_normalized_at" TIMESTAMP_WITH_TIMEZONE,\n\n    "make" VARCHAR,\n    "model" VARCHAR\n);\n\nCREATE TABLE "limited_editions" (\n    "_airbyte_limited_editions_hashid" VARCHAR,\n    "_airbyte_cars_foreign_hashid" VARCHAR,\n    "_airbyte_emitted_at" TIMESTAMP_WITH_TIMEZONE,\n    "_airbyte_normalized_at" TIMESTAMP_WITH_TIMEZONE,\n\n    "name" VARCHAR,\n    "release_year" VARCHAR\n);\n')),(0,i.kt)("p",null,"If the nested items in the array are not objects then they are expanded into a string field of comma separated values e.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "make": "alfa romeo",\n  "model": "4C coupe",\n  "limited_editions": [ "4C spider", "4C spider italia"]\n}\n')),(0,i.kt)("p",null,"The resulting normalized schema would be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE "cars" (\n    "_airbyte_cars_hashid" VARCHAR,\n    "_airbyte_emitted_at" TIMESTAMP_WITH_TIMEZONE,\n    "_airbyte_normalized_at" TIMESTAMP_WITH_TIMEZONE,\n\n    "make" VARCHAR,\n    "model" VARCHAR\n);\n\nCREATE TABLE "limited_editions" (\n    "_airbyte_limited_editions_hashid" VARCHAR,\n    "_airbyte_cars_foreign_hashid" VARCHAR,\n    "_airbyte_emitted_at" TIMESTAMP_WITH_TIMEZONE,\n    "_airbyte_normalized_at" TIMESTAMP_WITH_TIMEZONE,\n\n    "data" VARCHAR\n);\n')),(0,i.kt)("h4",{id:"objects"},"Objects"),(0,i.kt)("p",null,"In the case of a nested object e.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "make": "alfa romeo",\n  "model": "4C coupe",\n  "powertrain_specs": { "horsepower": 247, "transmission": "6-speed" }\n}\n')),(0,i.kt)("p",null,"The normalized schema would be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE "cars" (\n    "_airbyte_cars_hashid" VARCHAR,\n    "_airbyte_emitted_at" TIMESTAMP_WITH_TIMEZONE,\n    "_airbyte_normalized_at" TIMESTAMP_WITH_TIMEZONE,\n\n    "make" VARCHAR,\n    "model" VARCHAR\n);\n\nCREATE TABLE "powertrain_specs" (\n    "_airbyte_powertrain_hashid" VARCHAR,\n    "_airbyte_cars_foreign_hashid" VARCHAR,\n    "_airbyte_emitted_at" TIMESTAMP_WITH_TIMEZONE,\n    "_airbyte_normalized_at" TIMESTAMP_WITH_TIMEZONE,\n\n    "horsepower" INTEGER,\n    "transmission" VARCHAR\n);\n')),(0,i.kt)("h3",{id:"naming-collisions-for-un-nested-objects"},"Naming Collisions for un-nested objects"),(0,i.kt)("p",null,"When extracting nested objects or arrays, the Basic Normalization process needs to figure out new names for the expanded tables."),(0,i.kt)("p",null,"For example, if we had a ",(0,i.kt)("inlineCode",{parentName:"p"},"cars")," table with a nested column ",(0,i.kt)("inlineCode",{parentName:"p"},"cars")," containing an object whose schema is identical to the parent table."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},'{\n  "make": "alfa romeo",\n  "model": "4C coupe",\n  "cars": [\n    { "make": "audi", "model": "A7" },\n    { "make" : "lotus" , "model":  "elise" }\n    { "make" : "chevrolet" , "model":  "mustang" }\n  ]\n}\n')),(0,i.kt)("p",null,"The expanded table would have a conflict in terms of naming since both are named ",(0,i.kt)("inlineCode",{parentName:"p"},"cars"),". To avoid name collisions and ensure a more consistent naming scheme, Basic Normalization chooses the expanded name as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cars")," for the original parent table"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"cars_da3_cars")," for the expanded nested columns following this naming scheme in 3 parts: ",(0,i.kt)("inlineCode",{parentName:"li"},"<Json path>_<Hash>_<nested column name>")),(0,i.kt)("li",{parentName:"ul"},"Json path: The entire json path string with '","_","' characters used as delimiters to reach the table that contains the nested column name."),(0,i.kt)("li",{parentName:"ul"},"Hash: Hash of the entire json path to reach the nested column reduced to 3 characters. This is to make sure we have a unique name ","(","in case part of the name gets truncated, see below",")"),(0,i.kt)("li",{parentName:"ul"},"Nested column name: name of the column being expanded into its own table.")),(0,i.kt)("p",null,'By following this strategy, nested columns should "never" collide with other table names. If it does, an exception will probably be thrown either by the normalization process or by dbt that runs afterward.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE "cars" (\n    "_airbyte_cars_hashid" VARCHAR,\n    "_airbyte_emitted_at" TIMESTAMP_WITH_TIMEZONE,\n    "_airbyte_normalized_at" TIMESTAMP_WITH_TIMEZONE,\n\n    "make" VARCHAR,\n    "model" VARCHAR\n);\n\nCREATE TABLE "cars_da3_cars" (\n    "_airbyte_cars_hashid" VARCHAR,\n    "_airbyte_cars_foreign_hashid" VARCHAR,\n    "_airbyte_emitted_at" TIMESTAMP_WITH_TIMEZONE,\n    "_airbyte_normalized_at" TIMESTAMP_WITH_TIMEZONE,\n\n    "make" VARCHAR,\n    "model" VARCHAR\n);\n')),(0,i.kt)("h3",{id:"naming-limitations--truncation"},"Naming limitations & truncation"),(0,i.kt)("p",null,"Note that different destinations have various naming limitations, most commonly on how long names can be. For instance, the Postgres documentation states:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The system uses no more than NAMEDATALEN-1 bytes of an identifier; longer names can be written in commands, but they will be truncated. By default, NAMEDATALEN is 64 so the maximum identifier length is 63 bytes")),(0,i.kt)("p",null,"Most modern data warehouses have name lengths limits on the longer side, so this should not affect us that often. Basic Normalization will fallback to the following rules:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"No Truncate if under destination's character limits")),(0,i.kt)("p",null,"However, in the rare cases where these limits are reached:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Truncate only the ",(0,i.kt)("inlineCode",{parentName:"li"},"Json path")," to fit into destination's character limits"),(0,i.kt)("li",{parentName:"ol"},"Truncate the ",(0,i.kt)("inlineCode",{parentName:"li"},"Json path")," to at least the 10 first characters, then truncate the nested column name starting in the middle to preserve prefix/suffix substrings intact ","(","whenever a truncate in the middle is made, two '","_","_","' characters are also inserted to denote where it happened",")"," to fit into destination's character limits")),(0,i.kt)("p",null,"As an example from the hubspot source, we could have the following tables with nested columns:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Description"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Example 1"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Example 2"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"Original Stream Name"),(0,i.kt)("td",{parentName:"tr",align:"left"},"companies"),(0,i.kt)("td",{parentName:"tr",align:"left"},"deals")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"Json path to the nested column"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"companies/property_engagements_last_meeting_booked_campaign")),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("inlineCode",{parentName:"td"},"deals/properties/engagements_last_meeting_booked_medium"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"Final table name of expanded nested column on BigQuery"),(0,i.kt)("td",{parentName:"tr",align:"left"},"companies","_","2e8","_","property","_","engag",(0,i.kt)("strong",{parentName:"td"},"ements","_","last","_","meeting","_","bo"),"oked","_","campaign"),(0,i.kt)("td",{parentName:"tr",align:"left"},"deals","_","prop",(0,i.kt)("strong",{parentName:"td"},"erties"),"_","6e6","_","engagements","_","l",(0,i.kt)("strong",{parentName:"td"},"ast","_","meeting","_"),"booked","_","medium")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"Final table name of expanded nested column on Postgres"),(0,i.kt)("td",{parentName:"tr",align:"left"},"companies","_","2e8","_","property","_","engag",(0,i.kt)("strong",{parentName:"td"},"_","_"),"oked","_","campaign"),(0,i.kt)("td",{parentName:"tr",align:"left"},"deals","_","prop","_","6e6","_","engagements","_","l",(0,i.kt)("strong",{parentName:"td"},"_","_"),"booked","_","medium")))),(0,i.kt)("p",null,"As mentioned in the overview:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Airbyte places the json blob version of your data in a table called ",(0,i.kt)("inlineCode",{parentName:"li"},"_airbyte_raw_<stream name>"),"."),(0,i.kt)("li",{parentName:"ul"},"If basic normalization is turned on, it will place a separate copy of the data in a table called ",(0,i.kt)("inlineCode",{parentName:"li"},"<stream name>"),"."),(0,i.kt)("li",{parentName:"ul"},'In certain pathological cases, basic normalization is required to generate large models with many columns and multiple intermediate transformation steps for a stream. This may break down the "ephemeral" materialization strategy and require the use of additional intermediate views or tables instead. As a result, you may notice additional temporary tables being generated in the destination to handle these checkpoints.')),(0,i.kt)("h2",{id:"ui-configurations"},"UI Configurations"),(0,i.kt)("p",null,"To enable basic normalization ","(","which is optional",")",', you can toggle it on or disable it in the "Normalization and Transformation" section when setting up your connection:'),(0,i.kt)("p",null,(0,i.kt)("img",{src:a(5771).Z,width:"1140",height:"665"})),(0,i.kt)("h2",{id:"incremental-runs"},"Incremental runs"),(0,i.kt)("p",null,"When the source is configured with sync modes compatible with incremental transformations (using append on destination) such as ( ",(0,i.kt)("a",{parentName:"p",href:"/understanding-airbyte/connections/full-refresh-append"},"full_refresh_append"),", ",(0,i.kt)("a",{parentName:"p",href:"/understanding-airbyte/connections/incremental-append"},"incremental append")," or  ",(0,i.kt)("a",{parentName:"p",href:"/understanding-airbyte/connections/incremental-deduped-history"},"incremental deduped history"),"), only rows that have changed in the source are transferred over the network and written by the destination connector.\nNormalization will then try to build the normalized tables incrementally as the rows in the raw tables that have been created or updated since the last time dbt ran. As such, on each dbt run, the models get built incrementally. This limits the amount of data that needs to be transformed, vastly reducing the runtime of the transformations. This improves warehouse performance and reduces compute costs.\nBecause normalization can be either run incrementally and, or, in full refresh, a technical column ",(0,i.kt)("inlineCode",{parentName:"p"},"_airbyte_normalized_at")," can serve to track when was the last time a record has been transformed and written by normalization.\nThis may greatly diverge from the ",(0,i.kt)("inlineCode",{parentName:"p"},"_airbyte_emitted_at")," value as the normalized tables could be totally re-built at a latter time from the data stored in the ",(0,i.kt)("inlineCode",{parentName:"p"},"_airbyte_raw")," tables."),(0,i.kt)("h2",{id:"partitioning-clustering-sorting-indexing"},"Partitioning, clustering, sorting, indexing"),(0,i.kt)("p",null,"Normalization produces tables that are partitioned, clustered, sorted or indexed depending on the destination engine and on the type of tables being built. The goal of these are to make read more performant, especially when running incremental updates."),(0,i.kt)("p",null,"In general, normalization needs to do lookup on the last emitted_at column to know if a record is freshly produced and need to be\nincrementally processed or not. But in certain models, such as SCD tables for example, we also need to retrieve older data to update their type 2 SCD end_date and active_row flags, thus a different partitioning scheme is used to optimize that use case."),(0,i.kt)("p",null,"On Postgres destination, an additional table suffixed with ",(0,i.kt)("inlineCode",{parentName:"p"},"_stg")," for every stream replicated in  ",(0,i.kt)("a",{parentName:"p",href:"/understanding-airbyte/connections/incremental-deduped-history"},"incremental deduped history")," needs to be persisted (in a different staging schema) for incremental transformations to work because of a ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/dbt-labs/docs.getdbt.com/issues/335#issuecomment-694199569"},"limitation"),"."),(0,i.kt)("h2",{id:"extending-basic-normalization"},"Extending Basic Normalization"),(0,i.kt)("p",null,"Note that all the choices made by Normalization as described in this documentation page in terms of naming (and more) could be overridden by your own custom choices. To do so, you can follow the following tutorials:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"to build a ",(0,i.kt)("a",{parentName:"li",href:"/operator-guides/transformation-and-normalization/transformations-with-sql"},"custom SQL view")," with your own naming conventions"),(0,i.kt)("li",{parentName:"ul"},"to export, edit and run ",(0,i.kt)("a",{parentName:"li",href:"/operator-guides/transformation-and-normalization/transformations-with-dbt"},"custom dbt normalization")," yourself"),(0,i.kt)("li",{parentName:"ul"},"or further, you can configure the use of a custom dbt project within Airbyte by following ",(0,i.kt)("a",{parentName:"li",href:"/operator-guides/transformation-and-normalization/transformations-with-airbyte"},"this guide"),".")),(0,i.kt)("h2",{id:"changelog"},"CHANGELOG"),(0,i.kt)("h3",{id:"airbyte-integrationbasesbase-normalization"},"airbyte-integration/bases/base-normalization"),(0,i.kt)("p",null,"Note that Basic Normalization is packaged in a docker image ",(0,i.kt)("inlineCode",{parentName:"p"},"airbyte/normalization"),". This image is tied to and released along with a specific Airbyte version. It is not configurable independently like it is possible to do with connectors ","(","source & destinations",")"),(0,i.kt)("p",null,'Therefore, in order to "upgrade" to the desired normalization version, you need to use the corresponding Airbyte version that it\'s being released in:'),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"Airbyte Version"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Normalization Version"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Date"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Pull Request"),(0,i.kt)("th",{parentName:"tr",align:"left"},"Subject"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"}),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.2.1"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2022-05-17"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/12924"},"#","12924")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Fixed checking --event-buffer-size on old dbt crashed entrypoint.sh")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"}),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.2.0"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2022-05-15"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/12745"},"#","12745")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Snowflake: add datetime without timezone")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"}),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.78"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2022-05-06"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/12305"},"#","12305")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Mssql: use NVARCHAR and datetime2 by default")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.36.2-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.77"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2022-04-19"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/12064"},"#","12064")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Add support redshift SUPER type")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.35.65-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.75"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2022-04-09"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/11511"},"#","11511")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Move DBT modules from ",(0,i.kt)("inlineCode",{parentName:"td"},"/tmp/dbt_modules")," to ",(0,i.kt)("inlineCode",{parentName:"td"},"/dbt"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.35.61-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.74"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2022-03-24"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/10905"},"#","10905")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Update clickhouse dbt version")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.35.60-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.73"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2022-03-25"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/11267"},"#","11267")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Set ",(0,i.kt)("inlineCode",{parentName:"td"},"--event-buffer-size")," to reduce memory usage")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.35.59-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.72"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2022-03-24"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/11093"},"#","11093")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Added Snowflake OAuth2.0 support")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.35.53-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.71"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2022-03-14"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/11077"},"#","11077")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Enable BigQuery to handle project ID embedded inside dataset ID")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.35.49-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.70"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2022-03-11"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/11051"},"#","11051")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Upgrade dbt to 1.0.0 (except for MySQL and Oracle)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.35.45-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.69"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2022-03-04"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/10754"},"#","10754")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Enable Clickhouse normalization over SSL")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.35.32-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.68"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2022-02-20"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/10485"},"#","10485")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Fix row size too large for table with numerous ",(0,i.kt)("inlineCode",{parentName:"td"},"string")," fields")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"}),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.66"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2022-02-04"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/9341"},"#","9341")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Fix normalization for bigquery datasetId and tables")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.35.13-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.65"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-01-28"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/9846"},"#","9846")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Tweak dbt multi-thread parameter down")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.35.12-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.64"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-01-28"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/9793"},"#","9793")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Support PEM format for ssh-tunnel keys")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.35.4-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.63"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-01-07"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/9301"},"#","9301")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Fix Snowflake prefix tables starting with numbers")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"}),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.62"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-01-07"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/9340"},"#","9340")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Use TCP-port support for clickhouse")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"}),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.62"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-01-07"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/9063"},"#","9063")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Change Snowflake-specific materialization settings")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"}),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.62"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-01-07"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/9317"},"#","9317")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Fix issue with quoted & case sensitive columns")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"}),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.62"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-01-07"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/9281"},"#","9281")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Fix SCD partition by float columns in BigQuery")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.32.11-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.61"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-12-02"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/8394"},"#","8394")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Fix incremental queries not updating empty tables")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"}),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.61"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-12-01"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/8378"},"#","8378")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Fix un-nesting queries and add proper ref hints")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.32.5-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.60"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-11-22"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/8088"},"#","8088")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Speed-up incremental queries for SCD table on Snowflake")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.30.32-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.59"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-11-08"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/7169"},"#","7669")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Fix nested incremental dbt")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.30.24-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.57"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-10-26"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/7162"},"#","7162")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Implement incremental dbt updates")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.30.16-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.52"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-10-07"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/6379"},"#","6379")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Handle empty string for date and date-time format")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"}),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.51"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-10-08"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/6799"},"#","6799")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Added support for ad","_","cdc","_","log","_","pos while normalization")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"}),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.50"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-10-07"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/6079"},"#","6079")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Added support for MS SQL Server normalization")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"}),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.49"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-10-06"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/6709"},"#","6709")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Forward destination dataset location to dbt profiles")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.29.17-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.47"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-09-20"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/6317"},"#","6317")),(0,i.kt)("td",{parentName:"tr",align:"left"},"MySQL: updated MySQL normalization with using SSH tunnel")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"}),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.45"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-09-18"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/6052"},"#","6052")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Snowflake: accept any date-time format")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.29.8-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.40"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-08-18"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/5433"},"#","5433")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Allow optional credentials","_","json for BigQuery")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.29.5-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.39"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-08-11"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/4557"},"#","4557")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Handle date times and solve conflict name btw stream/field")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.28.2-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.38"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-07-28"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/5027"},"#","5027")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Handle quotes in column names when parsing JSON blob")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.27.5-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.37"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-07-22"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/4881/"},"#","3947")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Handle ",(0,i.kt)("inlineCode",{parentName:"td"},"NULL")," cursor field values when deduping")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"0.27.2-alpha"),(0,i.kt)("td",{parentName:"tr",align:"left"},"0.1.36"),(0,i.kt)("td",{parentName:"tr",align:"left"},"2021-07-09"),(0,i.kt)("td",{parentName:"tr",align:"left"},(0,i.kt)("a",{parentName:"td",href:"https://github.com/airbytehq/airbyte/pull/4163/"},"#","3947")),(0,i.kt)("td",{parentName:"tr",align:"left"},"Enable normalization for MySQL destination")))))}u.isMDXComponent=!0},5771:function(t,e,a){e.Z=a.p+"assets/images/basic-normalization-configuration-51e10ded7e650201094afc47cd757ab1.png"},25549:function(t,e,a){e.Z=a.p+"assets/images/connecting-EL-with-T-4-76a8ba79525fe9b69c81e4ca5ef0822e.png"}}]);